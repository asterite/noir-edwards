use dep::std;
use crate::scalar_field::ScalarField;

struct Curve {
    x: Field,
    y: Field,
}

global d: Field = 555;
impl Curve {
    unconstrained pub fn get_inverses(x1: Field, x2: Field, y1: Field, y2: Field) -> (Field, Field, Field) {
        let lambda = y1 * y2 * x1 * x2;
        let y = (x1 * x2 - y1 * y2) / (lambda * d - 1);
        let x = (x1 * y2 + y1 * x2) / (lambda * d + 1);
        (lambda, x, y)
    }

    fn add(self, other: Self) -> Self {
        let x1 = self.x;
        let x2 = other.x;
        let y1 = self.y;
        let y2 = other.y;
        let (lambda, x, y) = Curve::get_inverses(x1, x2, y1, y2);

        let x1x2 = x1 * x2;
        let x1y2 = x1 * y2;

        let x_lhs = x * (lambda * d + 1) - x1y2; // equals y1x2
        let y_lhs = y * (1 - lambda * d) + x1x2; // equals y1y2

        let y1x2 = y1 * x2;
        let y1y2 = y1 * y2;

        let y1y2x1x2 = y1y2 * x1x2;
        assert(x_lhs == y1x2);
        assert(y_lhs == y1y2);
        assert(y1y2x1x2 == lambda);
        Self { x, y }
    }

    fn dbl(self) -> Self {
        let x1 = self.x;
        let y1 = self.y;
        let (lambda, x, y) = Curve::get_inverses(x1, x1, y1, y1);

        let x1x1 = x1 * x1;
        let x1y1 = x1 * y1;

        let x_lhs = x * (lambda * d + 1) - x1y1; // equals x1y1
        let y_lhs = y * (1 - lambda * d) + x1x1; // equals y1y1

        let y1y1 = y1 * y1;
        let y1y2x1x2 = y1y1 * x1x1;
        assert(x_lhs == x1y1);
        assert(y_lhs == y1y1);
        assert(y1y2x1x2 == lambda);
        Self { x, y }
    }

    fn mul(self, scalar: ScalarField) -> Self {
        let mut T: [Curve;16] = [Curve { x: 0, y: 0 }; 16];
        T[0] = self;
        let D2 = self.dbl();
        for i in 1..15 {
            T[i] = T[i-1].add(D2);
        }

        let tableX: [Field; 16] = [
            T[0].x, T[1].x, T[2].x, T[3].x, T[4].x, T[5].x, T[6].x, T[7].x, T[8].x, T[9].x, T[10].x, T[11].x, T[12].x, T[13].x, T[14].x, T[15].x
        ];
        let tableY: [Field; 16] = [
            T[0].y, T[1].y, T[2].y, T[3].y, T[4].y, T[5].y, T[6].y, T[7].y, T[8].y, T[9].y, T[10].y, T[11].y, T[12].y, T[13].y, T[14].y, T[15].y
        ];

        let mut accumulator: Curve = Curve { x: 0, y: 0 };
        for i in 0..63 {
            // accumulator = accumulator.dbl();
            // accumulator = accumulator.dbl();
            // accumulator = accumulator.dbl();
            // accumulator = accumulator.dbl();
            let idx: u32 = scalar.get(i) as u32;
            //std::as_witness(idx);
            accumulator = accumulator.add(Curve{ x: tableX[idx], y:  tableY[idx]});
        }
        accumulator
    }
}
